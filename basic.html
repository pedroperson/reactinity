<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reactinity - Example 1</title>
  </head>
  <body>
    <!-- Add some basic css so we don't have to clutter the html for this example -->
    <style>
      * {
        box-sizing: border-box;
      }
      span[re] {
        font-weight: 700;
      }

      .my-page-width {
        width: 100%;
        max-width: 1400px;
        margin-left: auto;
        margin-right: auto;
        padding-left: 2em;
        padding-right: 2em;

        margin-top: 2em;
      }

      @media (max-width: 768px) {
        .my-page-width {
          padding-left: 1em;
          padding-right: 1em;
        }
      }
    </style>

    <style>
      .red {
        border: 1px solid red;
        color: red;
      }
    </style>

    <!-- Import the js code however you want -->
    <script src="/basic.js"></script>

    <!-- ---------------------------------------------------------------- -->
    <!-- INITIALIZE REACTINITY ------------------------------------------ -->
    <!-- ---------------------------------------------------------------- -->
    <script>
      const reactinity = new Reactinity();
      reactinity.defaultInit();
    </script>

    <!-- ---------------------------------------------------------------- -->
    <!-- 1. BASIC EXAMPLES ---------------------------------------------- -->
    <!-- We'll start with a simple counter example----------------------- -->
    <script>
      // The counter
      // Create a basic integer store
      const countStore = reactinity.newStore("count", 0);
      // Write some functions that interact with the store
      const Counter = {
        up: () => countStore.update((v) => v + 1),
        down: () => countStore.update((v) => v - 1),
        reset: () => countStore.set(0),
      };

      // Create a store whose value depends on another
      const relatedStore = reactinity.newStore("related", countStore.value);
      countStore.subscribe((v) => relatedStore.set(v + 100));

      // You can also use transforms render the current value of a store after feeding it through a set of functions. Here we are naming a transform "plus200" so we can reference it in the html.
      reactinity.newTransform("plus200", (v) => v + 200);
    </script>

    <section>
      Count = <span re="count"></span>;
      <span>C + 100 = <span re="related"></span>;</span>
      <span>C + 200 = <span re="count" re-transform="plus200"></span>;</span>
      <div>
        <button onclick="Counter.down()">-1</button>
        <button onclick="Counter.up()">+1</button>
        <button onclick="Counter.reset()">Reset</button>
      </div>
    </section>

    <!-- ---------------------------------------------------------------- -->
    <!-- OBJECT EXAMPLE ------------------------------------------------- -->
    <!-- ---------------------------------------------------------------- -->
    <script>
      // Reactinity can handle more complex data types like objects.
      const obj = reactinity.newStore("user", {
        name: "Michael Travis",
        joined: 1710853950,
        // Using an object inside of another just to show off
        interactions: {
          lastClicked: 0,
        },
      });

      // Imagine a function that updates specific fields of an object and displays the changes immediately
      function updateLastClicked() {
        // TODO: Consider an updateField store method for more fine-grained updates (instead of having to edit the whole object)
        obj.update((v) => {
          v.interactions.lastClicked = Date.now();
          return v;
        });
      }
    </script>

    <section>
      <!-- Target store fields directly using object notation -->
      <div>Name: <span re="user.name"></span></div>
      <!-- Transform objet field values directly -->
      <div>Joined: <span re="user.joined" re-transform="date"></span></div>
      <!-- Reactinity comes with some default transforms you can use. -->
      <div>
        Last interaction:
        <span re="user.interactions.lastClicked" re-transform="time"></span>
      </div>
      <button onclick="updateLastClicked()">Update interaction</button>
    </section>

    <!-- TODO:----------------------------------------------------------- -->
    <!-- CONDITIONAL DISPLAY EXAMPLE ------------------------------------ -->
    <!-- ---------------------------------------------------------------- -->

    <style>
      [re-show]:not(.re-show) {
        display: none;
      }
      [re-show-field]:not(.re-show) {
        display: none;
      }
    </style>

    <!-- ---------------------------------------------------------------- -->
    <!-- ARRAY EXAMPLE -------------------------------------------------- -->
    <!-- ---------------------------------------------------------------- -->

    <!-- Bring array logic in -->
    <script src="/array.js"></script>
    <!-- Keep the ArrayStore templates from showing from the start. is there are better way to do this ? Maybe we shouldn't care and just do it js asap? -->
    <style>
      [re-template] {
        display: none;
      }
    </style>

    <script>
      // Example Array Data
      const products = [
        {
          name: "shirt",
          price: 10000,
          country: { name: "Brazil", code: "BRA" },
          // TODO: An array inside an array is going to be a mess
          variants: [
            { color: "red", sizes: ["s", "m", "l"] },
            { color: "blue", sizes: ["s", "l"] },
          ],
        },
        {
          name: "skirt",
          price: 20000,
          new: true,
          country: { name: "Argentina", code: "ARG" },
          variants: [{ color: "red", sizes: ["l"] }],
        },
      ];

      // Turn said array into an ArrayStore. They are different from regular Store in that they have specific modification functions that allow the user to make fine-grained array modifications and have the DOM update accordingly.
      // TODO: The big question here is whether they should be different at all... I definitely don't want to need two factories, newStore and new arrayStore; the function should be able to tell, but maybe it null or something at load, so maybe all Store has all the crazy functions but we would need to check the type every time the function got called, and then the user would have to wait to runtime to tell them they made a mistake... So maybe they should be totally different like they are now
      const productsStore = reactinity.newArrayStore("products", products);
      // newArrayStore("products", products);

      // Define a more complex transform to get the numeric prices that come in as integers of cents to a formatted dollar string
      reactinity.newTransform("dollars", (cents) => {
        const opts = { style: "currency", currency: "USD" };
        return new Intl.NumberFormat("en-US", opts).format(cents / 100);
      });

      reactinity.newTransform("expensive", (cents) => cents > 10000);

      function addToCart(product) {
        console.log("TODO: add to cart", product);
      }
    </script>

    <!-- TODO: Im not super sold on the re-field vs re="_." debate.... if i have an array of numbers, how am i going to day this value? maybe an empty re-field?   -->

    <section>
      <!-- Use re-array to render similar repeating items in a list -->
      <div re-array="products">
        <!-- re-template defined the HTML for an item. Each value inside the products array will clone this template and populate it with relevant data  -->
        <div re-template>
          <div>
            <div>
              <!-- "re-field" works like "re" but for the field of the array objects -->
              <h3
                re="this.name"
                re-class="this.price"
                re-class-name="red"
                re-class-transform="expensive"
              ></h3>
              <!-- "re-field" also accepts nested objects -->
              <div re="this.country.name"></div>
            </div>
            <!-- "re-transform" still work with "re-field"s -->
            <div re="this.price" re-transform="dollars"></div>

            <div re-show="this.price" re-class-transform="expensive">
              WOW EXPENSIVE
            </div>

            <!-- JUST TESING -->
            <div
              re-array="this.variants"
              re-change
              onchange="selectedColor(event.item)"
            >
              <!-- I expect the event data to already have some data about the item, but really we also need an item.item on of each of the inputs to have a change listener -->
              <input re-template re-value="this.color" type="radio" name="c" />
            </div>

            <div re-array="this.variants">
              <div re-template re-array="this.sizes">
                <div re-template>
                  <div>The size: <span re="this"></span></div>
                  <input re-value="this" type="radio" name="s" />
                </div>
              </div>
            </div>
          </div>

          <!-- Use re-click to attach the array item to the click event object. Now it is easy to know which data related to the button being clicked -->
          <button
            re-click
            onclick="addToCart(event.item)"
            class="border border-black p-4 w-full flex-1 mt-3"
          >
            Add to cart
          </button>
        </div>
      </div>
    </section>
  </body>
</html>
