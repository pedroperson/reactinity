<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reactinity - Example 1</title>
  </head>
  <body>
    <!-- Add some basic css so we don't have to clutter the html for this example -->
    <style>
      * {
        box-sizing: border-box;
      }

      [re] {
        font-weight: 700;
      }

      section {
        width: 100%;
        max-width: 1400px;
        margin-left: auto;
        margin-right: auto;
        padding: 1em 1.5em;
        border-bottom: 1px solid black;
      }
    </style>

    <!-- Import the library js code -->
    <script src="/basic.js"></script>

    <!-- ---------------------------------------------------------------- -->
    <!-- INITIALIZE REACTINITY ------------------------------------------ -->
    <!-- ---------------------------------------------------------------- -->
    <script>
      const reactinity = new Reactinity();
      reactinity.defaultInit();
    </script>

    <!-- --------------------------------------------------------------- -->
    <!-- 1. SIMPLE STORES ---------------------------------------------- -->
    <!-- We'll start with a simple counter example---------------------- -->

    <section>
      <!-- DEFINE THE STORE -------------------------------------------- -->

      <script>
        // Create a basic integer store to track the value of our counter. Stores turn your data reactive, as we will see later.
        const countStore = reactinity.newStore("count", 0);
      </script>

      <!-- Connect the value of a store to an element with the *re* attribute. Everytime the store named in the attribute changes, its inner text will change to the same value. Notice we use the name "count" which is the name we gave to the countStore during initialization. -->
      Count = <span re="count"></span>;

      <!-- MANIPULATE THE STORE ---------------------------------------- -->
      <script>
        // You can manipulate the value of a store using the *update* and *set* methods. Both methods set a new value to a store and update its subscribers with the it.
        const Counter = {
          // *update* takes a function that receives the current store value and returns its new value
          up: () => countStore.update((v) => v + 1),
          down: () => countStore.update((v) => v - 1),
          // *set* takes in the new value of the store
          reset: () => countStore.set(0),
        };
      </script>

      <div>
        <button onclick="Counter.down()">-1</button>
        <button onclick="Counter.up()">+1</button>
        <button onclick="Counter.reset()">Reset</button>
      </div>

      <!-- TRANSFORMS ------------------------------------------------- -->
      <script>
        // We don't always want to render the value of the store directly. To modify the value we render we can use *transforms*. A *transform* is a function that takes a value, modifies it and returns its new value feeding it through a set of functions.
        // Reactinity has a newTransform hook where you can name and define a transform function that you can reference in the HTML. Here we are naming a transform "plus200" so we can reference it in the html. It simply take a value in and adds 200 to it.
        reactinity.newTransform("plus200", (v) => v + 200);
        // "timesTwo" instead just doubles a value, in the elements below we will use it in a chain with "plus200".
        reactinity.newTransform("timesTwo", (v) => v * 2);
      </script>

      <!-- Using the re attribute again to subscribe to the "count" store, then running it through our plus200 transform before rendering its value plus 200 -->
      <div>C + 200 = <span re="count" re-transform="plus200"></span></div>

      <!-- We can chain transforms by using commas as separators. In this case we expect the value of the "count" store to get 200 added to it then doubled. The transforms run in order from left to right.-->
      <div>
        (C + 200) * 2 = <span re="count" re-transform="plus200,timesTwo"></span>
      </div>

      <!-- RELATING STORES ---------------------------------------------- -->
      <script>
        // Stores can be connected to another store's value through the *subscribe* function.
        const relatedStore = reactinity.newStore("related", countStore.value);
        // Here we perform some change to the store value and update the value of our "relatedStore".
        countStore.subscribe((v) => relatedStore.set(v + 147));
      </script>
      <!-- Again, we subscribe to the store using the "re" attribute. -->
      <div>C + 147 = <span re="related"></span></div>
    </section>

    <!-- ---------------------------------------------------------------- -->
    <!-- OBJECT EXAMPLE ------------------------------------------------- -->
    <!-- ---------------------------------------------------------------- -->

    <section>
      <script>
        // Reactinity can handle more complex data types like objects.
        const userStore = reactinity.newStore("user", {
          name: "Michael Travis",
          joined: 1710853950,
          // Using an object inside of another just to show off
          interactions: {
            lastClicked: 0,
          },
        });

        // Imagine a function that updates specific fields of an object and displays the changes immediately
        function updateLastClicked() {
          userStore.update((v) => {
            v.interactions.lastClicked = Date.now();
            return v;
          });
        }
      </script>

      <!-- Target store fields directly using object notation -->
      <div>Name: <span re="user.name"></span></div>
      <!-- Transform objet field values directly -->
      <div>Joined: <span re="user.joined" re-transform="date"></span></div>
      <!-- Reactinity comes with some default transforms you can use. -->
      <div>
        Last interaction:
        <span re="user.interactions.lastClicked" re-transform="time"></span>
      </div>
      <button onclick="updateLastClicked()">Update interaction</button>
    </section>

    <!-- ---------------------------------------------------------------- -->
    <!-- CONDITIONAL DISPLAY EXAMPLE ------------------------------------ -->
    <!-- Lets start by showing and hiding an element on click ----------- -->

    <!-- Add a global style to hide templates by default -->
    <!-- NOT IDEAL HAVING TO DO THIS -->
    <style>
      [re-show]:not(.re-show) {
        display: none;
      }
    </style>

    <script>
      // A boolean store is useful for state that can be toggled
      const showBoxStore = reactinity.newStore("showBox", false);

      // Use a transform to conditionally display text
      reactinity.newTransform("showOrHide", (v) =>
        !v ? "Show Box" : "Hide Box"
      );
    </script>

    <section>
      <!-- Use a button to toggle the store -->
      <button onclick="showBoxStore.update(v=>!v)">
        <!-- Update the button text depending on the visibility -->
        <span re="showBox" re-transform="showOrHide"></span>
      </button>
      <!-- Conditionally display when showBox is truthy -->
      <div re-show="showBox">I start hidden!</div>
    </section>

    <!-- TODO:----------------------------------------------------------- -->
    <!-- CLASS EXAMPLE -------------------------------------------------- -->
    <!-- ---------------------------------------------------------------- -->

    <!-- Define some custome classes to toggle -->
    <style>
      .red {
        border: 1px solid red;
        color: red;
      }
      .max-w-100px {
        max-width: 100px;
      }
    </style>

    <script>
      const addClassStore = reactinity.newStore("addClass", false);
      reactinity.newTransform("addOrRemoveClass", (v) =>
        !v ? "Add Class" : "Remove Class"
      );
    </script>

    <section>
      <!-- Using a button to cause a data update -->
      <button
        onclick="addClassStore.update(v=>!v)"
        re="addClass"
        re-transform="addOrRemoveClass"
      ></button>
      <!-- Conditionally add classes inside *re-class-name* when the value of *re-class* is truthy after running them through the transform functions in *re-class-transform*. Classes can be separated by spaces -->
      <!-- TODO: Perform a transform just to show it off -->
      <div
        re-class="addClass"
        re-class-transform=""
        re-class-name="red max-w-100px"
      >
        I start with black text and full width
      </div>
    </section>

    <!-- ---------------------------------------------------------------- -->
    <!-- ARRAY EXAMPLE -------------------------------------------------- -->
    <!-- ---------------------------------------------------------------- -->

    <!-- Bring array logic in -->
    <!-- NOT IDEAL HAVING TO DO THIS -->
    <script src="/array.js"></script>
    <!-- Keep the ArrayStore templates from showing from the start. is there are better way to do this ? Maybe we shouldn't care and just do it js asap? -->
    <!-- NOT IDEAL HAVING TO DO THIS -->
    <style>
      [re-template] {
        display: none;
      }
    </style>

    <script>
      // Example Array Data
      const products = [
        {
          name: "shirt",
          price: 10000,
          country: { name: "Brazil", code: "BRA" },
          // TODO: An array inside an array is going to be a mess
          variants: [
            { color: "red", sizes: ["s", "m", "l"] },
            { color: "blue", sizes: ["s", "l"] },
          ],
        },
        {
          name: "skirt",
          price: 20000,
          new: true,
          country: { name: "Argentina", code: "ARG" },
          variants: [{ color: "red", sizes: ["l"] }],
        },
      ];

      // Turn said array into an ArrayStore. They are different from regular Store in that they have specific modification functions that allow the user to make fine-grained array modifications and have the DOM update accordingly.
      // TODO: The big question here is whether they should be different at all... I definitely don't want to need two factories, newStore and new arrayStore; the function should be able to tell, but maybe it null or something at load, so maybe all Store has all the crazy functions but we would need to check the type every time the function got called, and then the user would have to wait to runtime to tell them they made a mistake... So maybe they should be totally different like they are now
      const productsStore = reactinity.newArrayStore("products", products);
      // newArrayStore("products", products);

      // Define a more complex transform to get the numeric prices that come in as integers of cents to a formatted dollar string
      reactinity.newTransform("dollars", (cents) => {
        const opts = { style: "currency", currency: "USD" };
        return new Intl.NumberFormat("en-US", opts).format(cents / 100);
      });

      reactinity.newTransform("expensive", (cents) => cents > 10000);

      function addToCart(product) {
        console.log("TODO: add to cart", product);
      }
    </script>

    <!-- TODO: Im not super sold on the re-field vs re="_." debate.... if i have an array of numbers, how am i going to day this value? maybe an empty re-field?   -->

    <section>
      <!-- Use re-array to render similar repeating items in a list -->
      <div re-array="products">
        <!-- re-template defined the HTML for an item. Each value inside the products array will clone this template and populate it with relevant data  -->
        <div re-template>
          <div>
            <div>
              <!-- "re-field" works like "re" but for the field of the array objects -->
              <h3
                re="this.name"
                re-class="this.price"
                re-class-name="red"
                re-class-transform="expensive"
              ></h3>
              <!-- "re-field" also accepts nested objects -->
              <div re="this.country.name"></div>
            </div>
            <!-- "re-transform" still work with "re-field"s -->
            <div re="this.price" re-transform="dollars"></div>

            <div re-show="this.price" re-class-transform="expensive">
              WOW EXPENSIVE
            </div>

            <!-- JUST TESING -->
            <div
              re-array="this.variants"
              re-change
              onchange="selectedColor(event.item)"
            >
              <!-- I expect the event data to already have some data about the item, but really we also need an item.item on of each of the inputs to have a change listener -->
              <input re-template re-value="this.color" type="radio" name="c" />
            </div>

            <div re-array="this.variants">
              <!-- TODO: an array of base values (string or integer or whatever) -->
              <div re-template re-array="this.sizes">
                <div re-template>
                  <!-- TODO: rendering the base value -->
                  <div>The size: <span re="this"></span></div>
                  <input re-value="this" type="radio" name="s" />
                </div>
              </div>
            </div>
          </div>

          <!-- TODO: Something to complicate us a bit.  A global store (not "this") inside an array needs to be subscribed by the array-->
          <div>count: <span re="count"></span></div>

          <!-- Use re-click to attach the array item to the click event object. Now it is easy to know which data related to the button being clicked -->
          <button
            re-click
            onclick="addToCart(event.item)"
            class="border border-black p-4 w-full flex-1 mt-3"
          >
            Add to cart
          </button>
        </div>
      </div>
    </section>
  </body>
</html>
